clear
clc
l
L
x <- 0.8836+0.0564+0.0009+0.0376
x - 0.0376
x
0.0375-0.0215
d <- 0.0215+0.0012+0.00188+0.004+0.006+0.004+0.001
0.0215*4+0.0012*6+0.00188*9+0.0004*10+0.0006*11+0.0004*15+0.0001*20
0.12872/d
0.12872/0.05
runTime <- c(0.001418138, 4.95523E-4, 0.001440276, 0.005974989, 0.009176647, 0.010530942, 0.047961293, 0.198864462, 0.875263574, 3.968954248, 16.478082562, 68.734433724, 279.915478711)
plot(runTime)
dimension <- c(2,4,8,16,32,64,128,256,512,1024,2048,4096,8192)
plot(dimension, runTime)
plot(dimension, runTime, 'lines')
plot(dimension, runTime, 'lines', main="Minimal Flexible Distance Algorithm 1000 replications",
xlab="Dimension [N]", ylab="run-time [millisecond]")
plot(dimension, runTime, 'lines', main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
runTime <- c(0.001418138, 4.95523E-4, 0.001440276, 0.005974989, 0.009176647, 0.010530942, 0.047961293, 0.198864462, 0.875263574, 3.968954248, 16.478082562, 68.734433724, 279.915478711, 1070.830521243)
dimension <- c(2,4,8,16,32,64,128,256,512,1024,2048,4096,8192, 16384)
plot(dimension, runTime, 'lines', main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, 'lines',col="26",
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, 'lines', col="b",
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, 'lines', col="bl",
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, type="lines", col="bl",
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, type='lines', col='bl',
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime, type='lines',,
plot(dimension, runTime, type='lines',
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime,'lines',
main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime,'lines',main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime,'lines', colors="blue", main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
plot(dimension, runTime,'lines', col="blue", main="Minimal Flexible Distance Algorithm: 1000 replications",
xlab="Dimension", ylab="run-time [millisecond]")
install.packages("quantmod")
# http://www2.stat.duke.edu/~rcs46/lectures_2015/02-multivar2/02-multivar2.pdf
library(mvtnorm)
# Fixing the seed gives us a consistent set of simulated returns
set.seed(42)
HDIofICDF = function( ICDFname , credMass=0.95, tol=1e-8 , ... ) {
# Arguments:
#   ICDFname is R's name for the inverse cumulative density function
#     of the distribution.
#   credMass is the desired mass of the HDI region.
#   tol is passed to R's optimize function.
# Return value:
#   Highest density iterval (HDI) limits in a vector.
# Example of use: For determining HDI of a beta(30,12) distribution, type
#   HDIofICDF( qbeta , shape1 = 30 , shape2 = 12 )
#   Notice that the parameters of the ICDFname must be explicitly named;
#   e.g., xdoes not work.
# Adapted and corrected from Greg Snow's TeachingDemos package.
incredMass =  1.0 - credMass
intervalWidth = function( lowTailPr , ICDFname , credMass , ... ) {
ICDFname( credMass + lowTailPr , ... ) - ICDFname( lowTailPr , ... )
}
optInfo = optimize( intervalWidth , c( 0 , incredMass ) , ICDFname=ICDFname ,
credMass=credMass , tol=tol , ... )
HDIlowTailPr = optInfo$minimum
return( c( ICDFname( HDIlowTailPr , ... ) ,
ICDFname( credMass + HDIlowTailPr , ... ) ) )
}
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
d <- rnorm(1000000) # returns the density data
plot(density(d)) # plots the results
?quantile
?qnorm
qnorm(0.95)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.975)
qnorm(0.975)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
HDIofICDF(ICDFname=qmvnorm, mean=0, sigma=diag(2), credMass=0.95)
?qmvnorm
HDIofICDF(ICDFname=qmvnorm(mean=0, sigma=diag(2)), credMass=0.95)
HDIofICDF(ICDFname=qmvnorm(p=0.95, mean=0, sigma=diag(2)), credMass=0.95)
?qnorm
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
?qmvnorm
HDIofICDF(ICDFname=qmvnorm, mean=c(0,0), sigma=diag(2), credMass=0.95)
x <- seq(0.4,12,0.4)
px <-  c(0,0, 0, 0, 0, 0, 0.0002, 0.0037, 0.018, 0.06, 0.22 ,0.43, 0.64,0.7579, 0.7870, 0.72, 0.555, 0.37, 0.24, 0.11, 0.07, 0.02, 0.009, 0.005, 0.0001, 0,0.0002, 0, 0, 0)
plot(x,px, type="l")
?optimize
####
x <- seq(0.4,12,0.4)
px <-  c(0,0, 0, 0, 0, 0, 0.0002, 0.0037, 0.018, 0.06, 0.22 ,0.43, 0.64,0.7579, 0.7870, 0.72, 0.555, 0.37, 0.24, 0.11, 0.07, 0.02, 0.009, 0.005, 0.0001, 0,0.0002, 0, 0, 0)
xx <- seq(min(x), max(x), by = 0.001)
# interpolate function from the sample
fx <- splinefun(x, px) # interpolating function
pxx <- pmax(0, fx(xx)) # normalize so prob >0
fx
pxx
# Find highest density region numerically
const <- sum(pxx)
spxx <- sort(pxx, decreasing = TRUE) / const
View(spxx)
x
px
pxx
?pmax
View(pxx)
install.packages(hdrcde)
install.packages("hdrcde")
library(hdrcde)
# Highly skewed example
x <- exp(rnorm(100,0,1))
par(mfrow=c(1,2))
boxplot(x)
hdr.boxplot(x,lambda=0)
# Simple bimodal example
x <- c(rnorm(100,0,1), rnorm(100,5,1))
par(mfrow=c(1,2))
boxplot(x)
hdr.boxplot(x)
par(mfrow=c(1,1))
hdr.den(x)
View(x)
# Simple bimodal example
x <- c(rnorm(100,0,1), rnorm(100,5,1), rnorm(100,-2,1))
hdr.den(x)
# Bivariate example
x <- c(rnorm(200,0,1),rnorm(200,4,1))
y <- c(rnorm(200,0,1),rnorm(200,4,1))
hdrinfo <- hdr.2d(x,y)
View(hdrinfo)
View(hdrinfo)
# Bivariate example
x <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(x)
y <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(y)
# Bivariate example
par(mfrow=c(1,2))
x <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(x)
y <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(y)
# Bivariate example
par(mfrow=c(1,2))
x <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(x)
y <- c(rnorm(200,3,2),rnorm(200,4,1)); hdr.den(y)
x <- c(rnorm(200,0,1),rnorm(200,2,1)); hdr.den(x)
y <- c(rnorm(200,0,1),rnorm(200,5,1)); hdr.den(y)
y <- c(rnorm(200,0,1),rnorm(200,5,0.3)); hdr.den(y)
hdrinfo <- hdr.2d(x,y)
# Bivariate example
x <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(x)
y <- c(rnorm(200,0,1),rnorm(200,4,1)); hdr.den(y)
hdrinfo <- hdr.2d(x,y)
# Bivariate example
x <- c(rnorm(200,0,1),rnorm(200,4,1)); #hdr.den(x)
y <- c(rnorm(200,0,1),rnorm(200,4,1)); #hdr.den(y)
hdrinfo <- hdr.2d(x,y)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=3)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=2)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=1)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=4)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=3)
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=3)
hdrinfo
hdrinfo
hdrinfo <- hdr.2d(x,y)
hdrinfo
#################################################################################################################
rm(list=ls())  # remove all variables in R
library(tseries)
library(rugarch)
library(rmgarch)
library(rootSolve)
library(parallel)
library(zoo)
library(fGarch)
setwd("~/Documents/Python/PycharmProjects/ml_tue2017/source/main/resources/Data/multivariate_analysis")
source("R/fun_VaR_backtesting.R")
set.seed(42)  # 42:The answer to life, the universe and everything.
# Data sample import
df <- read.csv("DJI30_returns_1987_2001.csv", row.names=1, header=T)
####################################################################################################
######                               Tranquil Market Conditions                              #######
####################################################################################################
data <- df[1:2224,]  # Data sample: 17/3/1987-29/12/1995
data$Date <- NULL
T <- 504  # Out-of-sample test sample: 3/1/1994-29/12/1995
N <- 30  # number of assets under consideration
w <- c(rep(1/N, N))  # asset weight vector (assume equal weights)
# Same first stage conditional mean filtration (unconditional mean)
a_t <- data - rep(colMeans(data), rep.int(nrow(data), ncol(data)))  # r_t - mu_t = a_t = epsilon_t
t <- c((nrow(data)-T):(nrow(data)-1))
mu_portfolio_loss <- w%*%colMeans(data)  # Expected portfolio return (assumed constant through sample mean)
## Load conditional correlations and volatilities data
vol_data_tranquil_mvnorm<- read.csv(file="volatilities_mvnorm_DJI30_1994_1995.csv", row.names=1)
cor_DCCgarch_tranquil_mvnorm <- read.csv(file="cor_DCC_mvnorm_DJI30_1994_1995.csv", row.names=1)
## Compute portfolio conditional covariances
# Multivariate Normal distributed errors
sigma_DCCgarch_tranquil_mvnorm <- sigma_vec_portfolio(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, T=T, w=w)
H_t <- cov_mat_portfolio(as.numeric(vol_data_tranquil_mvnorm[1,]), as.numeric(cor_DCCgarch_tranquil_mvnorm[1,]))
H_t
qmvnorm(p=0.95, mu=colMeans(data) , sigma=H_t, tail="lower.tail")$quantile
qmvnorm(p=0.95, mu=colMeans(data) , sigma=H_t, tail="lower.tail")
qmvnorm(p=0.05, mu=colMeans(data) , sigma=H_t, tail="lower.tail")
qmvnorm(p=0.05, sigma=H_t, tail="lower.tail")
qmvnorm(p=0.05, sigma=H_t, tail="lower.tail")
qmvnorm(p=0.01, sigma=H_t, tail="lower.tail")
library(hdrcde)
?rnorm
x <- rnorm(100, 0, 1)
hdr.den(x)
x <- rnorm(1000, 0, 1)
hdr.den(x)
qnorm(x)
?qnorm
qnorm(p=c(0.50, 0.95, 0.99), mean = 0, sd = 1, lower.tail = TRUE)
hdr.den(x)
hdr.den(x)$hdr
hdr.den(x)$hdr
qnorm(p=c(0.50, 0.95, 0.99), mean = 0, sd = 1, lower.tail = TRUE)
HDIofICDF = function( ICDFname , credMass=0.95, tol=1e-8 , ... ) {
# Arguments:
#   ICDFname is R's name for the inverse cumulative density function
#     of the distribution.
#   credMass is the desired mass of the HDI region.
#   tol is passed to R's optimize function.
# Return value:
#   Highest density iterval (HDI) limits in a vector.
# Example of use: For determining HDI of a beta(30,12) distribution, type
#   HDIofICDF( qbeta , shape1 = 30 , shape2 = 12 )
#   Notice that the parameters of the ICDFname must be explicitly named;
#   e.g., xdoes not work.
# Adapted and corrected from Greg Snow's TeachingDemos package.
incredMass =  1.0 - credMass
intervalWidth = function( lowTailPr , ICDFname , credMass , ... ) {
ICDFname( credMass + lowTailPr , ... ) - ICDFname( lowTailPr , ... )
}
optInfo = optimize( intervalWidth , c( 0 , incredMass ) , ICDFname=ICDFname ,
credMass=credMass , tol=tol , ... )
HDIlowTailPr = optInfo$minimum
return( c( ICDFname( HDIlowTailPr , ... ) ,
ICDFname( credMass + HDIlowTailPr , ... ) ) )
}
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
HDIofICDF(ICDFname=qmvnorm, mean=c(0,0), sigma=diag(2), credMass=0.95)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.95)
qnorm(p=c(0.95), mean = 0, sd = 1, lower.tail = TRUE)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.90)
x <- rnorm(1000000, 0, 1)
hdr.den(x)$hdr
?hdr.den
hdr.den(x, prob = c(90))$hdr
qnorm(p=c(0.95), mean = 0, sd = 1, lower.tail = TRUE)
x <- rnorm(1000000, 0, 1)
y <- rnorm(1000000, 0, 1)
hdrinfo <- hdr.2d(x,y)
hdrinfo
hdrinfo
?hdr.2d
hdrinfo <- hdr.2d(x=x, y=x ,prob=c(0.90))
hdrinfo
hdrinfo
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=3)
hdrinfo$alpha
hdrinfo$mode
hdrinfo$falpha
hdrinfo$den
hdrinfo$fxy
x <- rnorm(100, 0, 1)
hdrinfo <- hdr.2d(x=x, y=x ,prob=c(0.90))
hdrinfo$fxy
x <- rnorm(100, 0, 1)
hdrinfo <- hdr.2d(x=x, y=x ,prob=c(0.90))
hdrinfo
y <- rnom(100, 0, 1)
y <- rnorm(100, 0, 1)
hdrinfo <- hdr.2d(x=x, y=y ,prob=c(0.90))
hdrinfo
x <- rnorm(1000, 0, 1)
y <- rnorm(1000, 0, 1)
hdrinfo <- hdr.2d(x=x, y=y ,prob=c(0.90))
hdrinfo
hdrinfo
View(hdrinfo)
View(hdrinfo)
quantile(hdrinfo$fxy, 0.9)
quantile(hdrinfo$fxy, 0.9)
quantile(hdrinfo$fxy, 0.9)
which(hdrinfo$fxy %in% c(quantile(hdrinfo$fxy, 0.9))
which(hdrinfo$fxy %in% c(quantile(hdrinfo$fxy, 0.9)))
which(quantile(hdrinfo$fxy, 0.9) %in% hdrinfo$fxy)
HDIofICDF(ICDFname=qmvnorm, mean=c(0,0), sigma=diag(2), credMass=0.95)
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.90)
hdrinfo
x <- rnorm(10, 0, 1)
y <- rnorm(10, 0, 1)
hdrinfo <- hdr.2d(x=x, y=y, prob=c(0.90))
hdrinfo
x <- rnorm(100, 0, 1)
y <- rnorm(100, 0, 1)
hdrinfo <- hdr.2d(x=x, y=y, prob=c(0.90))
hdrinfo
x <- rnorm(10, 0, 1)
y <- rnorm(10, 0, 1)
hdrinfo <- hdr.2d(x=x, y=y, prob=c(0.90))
hdrinfo
HDIofICDF(ICDFname=qnorm, mean=0, sd=1, credMass=0.90)
hdrinfo <- hdr.2d(x=x, y=y, prob=c(0.90))
hdrinfo
H_t <- cov_mat_portfolio(as.numeric(vol_data_tranquil_mvnorm[1,]), as.numeric(cor_DCCgarch_tranquil_mvnorm[1,]))
qmvnorm(p=0.95, sigma=H_t, tail="lower.tail")
qmvnorm(p=0.99, sigma=H_t, tail="lower.tail")
lebgth(vol_data_tranquil_mvnorm)
length(vol_data_tranquil_mvnorm)
dim(vol_data_tranquil_mvnorm)
dim(vol_data_tranquil_mvnorm)[0]
dim(vol_data_tranquil_mvnorm)[0]1
dim(vol_data_tranquil_mvnorm)[§]
dim(vol_data_tranquil_mvnorm)[1]
?qmvnorm
qmvnorm(0.95, sigma = diag(2), tail = "both")
qmvnorm(0.95, sigma = diag(2), tail = "lower")
qmvnorm(0.95, sigma = diag(3), tail = "lower")
qmvnorm(0.95, sigma = diag(4), tail = "lower")
qmvnorm(0.95, sigma = diag(4), tail = "lower")
source("R/fun_VaR_backtesting.R")
mu_portfolio_loss <- colMeans(data)
#################################################################################################################
rm(list=ls())  # remove all variables in R
library(tseries)
library(rugarch)
library(rmgarch)
library(rootSolve)
library(parallel)
library(zoo)
library(fGarch)
setwd("~/Documents/Python/PycharmProjects/ml_tue2017/source/main/resources/Data/multivariate_analysis")
source("R/fun_VaR_backtesting.R")
set.seed(42)  # 42:The answer to life, the universe and everything.
# Data sample import
df <- read.csv("DJI30_returns_1987_2001.csv", row.names=1, header=T)
####################################################################################################
######                               Tranquil Market Conditions                              #######
####################################################################################################
data <- df[1:2224,]  # Data sample: 17/3/1987-29/12/1995
data$Date <- NULL
T <- 504  # Out-of-sample test sample: 3/1/1994-29/12/1995
N <- 30  # number of assets under consideration
w <- c(rep(1/N, N))  # asset weight vector (assume equal weights)
# Same first stage conditional mean filtration (unconditional mean)
a_t <- data - rep(colMeans(data), rep.int(nrow(data), ncol(data)))  # r_t - mu_t = a_t = epsilon_t
t <- c((nrow(data)-T):(nrow(data)-1))
####    Value-at-Risk Estimation   ###
alpha <- c(0.99, 0.975, 0.95, 0.9, 0.8, 0.6, 0.4, 0.2, 0.1, 0.05, 0.025, 0.01)
## Load conditional correlations and volatilities data
vol_data_tranquil_mvnorm<- read.csv(file="volatilities_mvnorm_DJI30_1994_1995.csv", row.names=1)
cor_DCCgarch_tranquil_mvnorm <- read.csv(file="cor_DCC_mvnorm_DJI30_1994_1995.csv", row.names=1)
mu_portfolio_loss <- colMeans(data)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss, cl=alpha)
View(var_test)
View(vol_data_tranquil_mvnorm)
View(cor_DCCgarch_tranquil_mvnorm)
volatility_matrix[i1]
vol_data_tranquil_mvnorm[1,]
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
View(var_test)
View(var_test)
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
mu_portfolio_loss <- colMeans(data)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
source("R/fun_VaR_backtesting.R")
mu_portfolio_loss <- colMeans(data)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_portfolio_loss,cl=alpha)
View(var_test)
View(var_test)
t
w
t(w)
## Value-at-Risk Computation
# Multivariate Normal distributed errors
dcc_VaR_tranquil_mvnorm <- VaR_estimates(sigma_portfolio=sigma_DCCgarch_tranquil_mvnorm, mu= mu_portfolio_loss, cl=alpha)
## Compute portfolio conditional covariances
# Multivariate Normal distributed errors
sigma_DCCgarch_tranquil_mvnorm <- sigma_vec_portfolio(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, T=T, w=w)
source("R/fun_VaR_backtesting.R")
## Compute portfolio conditional covariances
# Multivariate Normal distributed errors
sigma_DCCgarch_tranquil_mvnorm <- sigma_vec_portfolio(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, T=T, w=w)
## Compute portfolio conditional covariances
# Multivariate Normal distributed errors
sigma_DCCgarch_tranquil_mvnorm <- sigma_vec_portfolio(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, T=T, w=w)
source("R/fun_VaR_backtesting.R")
## Compute portfolio conditional covariances
# Multivariate Normal distributed errors
sigma_DCCgarch_tranquil_mvnorm <- sigma_vec_portfolio(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, T=T, w=w)
## Value-at-Risk Computation
# Multivariate Normal distributed errors
dcc_VaR_tranquil_mvnorm <- VaR_estimates(sigma_portfolio=sigma_DCCgarch_tranquil_mvnorm, mu= mu_portfolio_loss, cl=alpha)
mu_portfolio_loss <- w%*%colMeans(data)  # Expected portfolio return (assumed constant through sample mean)
## Value-at-Risk Computation
# Multivariate Normal distributed errors
dcc_VaR_tranquil_mvnorm <- VaR_estimates(sigma_portfolio=sigma_DCCgarch_tranquil_mvnorm, mu= mu_portfolio_loss, cl=alpha)
View(dcc_VaR_tranquil_mvnorm)
View(dcc_VaR_tranquil_mvnorm[1:5,])
qnorm(0.05)
source("R/fun_VaR_backtesting.R")
source("R/fun_VaR_backtesting.R")
mu_alt <- colMeans(data)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu_alt,cl=alpha)
var_test <- VaR_estimates(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_alt,cl=alpha)
var_test <- VaR_estimates_alt(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_alt,cl=alpha)
View(var_test)
View(dcc_VaR_tranquil_mvnorm[1:3,])
View(var_test[1:3,])
var_test <- VaR_estimates_alt(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_portfolio_loss,cl=alpha)
source("R/fun_VaR_backtesting.R")
set.seed(42)  # 42:The answer to life, the universe and everything.
var_test <- VaR_estimates_alt(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_portfolio_loss,cl=alpha)
View(dcc_VaR_tranquil_mvnorm[1:3,])
View(var_test[1:3,])
rep(0,30)
c <- c(rep(0, 30))
c
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates_alt(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_portfolio_loss,cl=alpha)
View(var_test[1:3,])
source("R/fun_VaR_backtesting.R")
var_test <- VaR_estimates_alt(vol_data_tranquil_mvnorm, cor_DCCgarch_tranquil_mvnorm, mu=mu_portfolio_loss,cl=alpha)
View(var_test[1:3,])
qmvnorm(p=0.95, tail="lower", mu=c(rep(0, 30)), sigma=diag(10))$quantile
qmvnorm(p=0.05, tail="lower", mu=c(rep(0, 30)), sigma=diag(10))$quantile
qmvnorm(p=0.95, tail="both", mu=c(rep(0, 30)), sigma=diag(10))$quantile
qmvnorm(p=0.95, tail="both", mu=c(rep(0, 30)), sigma=diag(10))$quantile
qmvnorm(p=0.95, tail="both", mu=c(rep(0, 30)), sigma=diag(10))
qmvnorm(p=0.95, tail="both.tails", mu=c(rep(0, 30)), sigma=diag(10))
qmvnorm(p=0.95, tail="both.tails", mu=c(rep(0, 30)), sigma=diag(10))
qmvnorm(p=0.95, tail="both.tails", sigma=diag(2))
qmvnorm(p=0.95, tail="both.tails", sigma=diag(1))
qmvnorm(p=0.95, tail="lower.tail", sigma=diag(1))
qnorm(0.95)
qmvnorm(p=0.99, tail="lower.tail", sigma=diag(1))
qnorm(0.95)
qnorm(0.99)
qmvnorm(p=0.99, tail="lower.tail", sigma=diag(2))
######
install.packages("SELECTIONGAIN")
######
install.packages("selectiongain")
library(selectiongain)
corr=diag(2)
corr
calculatefromalpha(alpha, dim=2, corr=corr)
calculatefromalpha(alpha, dim=2, corr=corr)
library(selectiongain)
calculatefromalpha(alpha, dim=2, corr=corr)
######
install.packages("selectiongain")
install.packages("selectiongain")
library(selectiongain)
alpha=9095
alpha=0.95
corr=diag(2)
calculatefromalpha(alpha, dim=2, corr=corr)
library(selectiongain)
alpha=0.95
corr=diag(2)
calculatefromalpha(alpha, dim=2, corr=corr)
