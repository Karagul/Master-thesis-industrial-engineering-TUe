for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
View(data)
View(a_t)
View(a_t)
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
####################################################################################################
######                               Volatile Market Conditions                              #######
####################################################################################################
rm(list=ls())  # remove all variables in R
set.seed(42)
setwd("~/Documents/Python/PycharmProjects/thesisOML/ml_tue2017/source/main/resources/Data/multivariate_analysis")
library(rugarch)
library(rmgarch)
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
set.seed(42)
setwd("~/Documents/Python/PycharmProjects/thesisOML/ml_tue2017/source/main/resources/Data/multivariate_analysis")
df <- read.csv("DJI30_returns_volatile.csv")
N <- 30  # number of assets under consideration
w <- c(rep(1/N, N))  # asset weight vector (assume equal weights)
data <- df[-c(1:10), ]  # Data sample 2/1/2004-31/12/2008
rownames(data) <- seq(length=nrow(data))  # reset index
data$X <- NULL  # Drop first column with indices
data$Date <- NULL
T <- 253  # Length out-of-sample test set
a_t <- data - rep(colMeans(data), rep.int(nrow(data), ncol(data)))  # r_t - mu_t = a_t = epsilon_t
t <- c((nrow(data)-T):(nrow(data)-1))   # c(1006:1258)
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
warnings()
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
cl = makePSOCKcluster(10)
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
stopCluster(cl)
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in seq_along(t)) {
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
close.socket(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
close(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
#D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
print(tail(sigma(fit.multi_garch),1))
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
print(D_t_file[1, 1:N])
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
print(D_t_file[1, 1:N])
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:10) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
print(D_t_file[1, 1:N])
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:1) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
print(data_train)
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:1) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
print(data_train)
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
View(dcc_garch_modeling)
View(dcc_garch_modeling)
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:1) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
print(data_train)
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_filem "fit.multi_garch"=fit.multi_garch))
}
# Two-stage quasi-likelihood function to find parameters under multivariate Student-t distributed errors
dcc_garch_modeling <- function(data=a_t, distribution.model="norm", distribution="mvnorm") {
D_t_file <- matrix(NaN, T, N)
colnames(D_t_file) <- c(colnames(data))[1:N]
R_t_file <- matrix(NaN, T, N*(N-1)/2)
cl = makePSOCKcluster(10)
for (i in 1:1) { # (i in seq_along(t))
tic <- Sys.time()
data_train <- data[i:(t[i]+1),1:N]  # Rolling forward training set
print(data_train)
# Specify univariate GARCH(1,1) with marginal Student-t dist. errors for each component series
univ_garch_spec <- ugarchspec(variance.model=list(model="fGARCH", submodel="GARCH", garchOrder=c(1, 1)),
mean.model=list(armaOrder=c(0,0), include.mean=FALSE), distribution.model=distribution.model)
multi_univ_garch_spec <- multispec(replicate(N,univ_garch_spec))
# Specify DCC-GARCH(1,1) with multivariate Student-t errors for stand. residual series
dcc_spec <- dccspec(multi_univ_garch_spec, dccOrder=c(1,1), model="DCC", distribution=distribution)
# Fit component series
fit.multi_garch <- multifit(multi_univ_garch_spec, data_train, cluster=cl)
print(tail(sigma(fit.multi_garch),1))
# Estimate DCC-GARCH(1,1) mvt model
#fit.dcc = dccfit(dcc_spec, data=data_train, solver='solnp', cluster=cl, fit.control=list(eval.se = FALSE), fit=fit.multi_garch)
# Save conditional volatilities and correlations
D_t_file[i, ] <- tail(sigma(fit.multi_garch),1)
#R_t_file[i, ] <- t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]])[lower.tri(t(rcor(fit.dcc)[,,dim(rcor(fit.dcc))[3]]),diag=FALSE)]
print(i)
print(t[i])
print(Sys.time()-tic)
}
stopCluster(cl)
return(list("D_t_file"=D_t_file, "R_t_file"=R_t_file, "fit.multi_garch"=fit.multi_garch))
}
dccGarch_mvnorm <- dcc_garch_modeling(data=a_t, distribution.model="norm", distribution="mvnorm")
View(dcc_garch_modeling)
View(dcc_garch_modeling)
